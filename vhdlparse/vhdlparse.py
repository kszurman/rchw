#!/usr/bin/env python

# attempt at a simple VHDL parser
# the purpose is
#  - automatically generate entity wrapper's
#  - generate documentation / graphs, see also vhdldoc

# 20110823 oswald berthold

from pyparsing import *
import sys
from optparse import OptionParser
import string

VERSION = 0

vhdfile = sys.argv[1]

f = open(vhdfile, "r")
vhdstring = f.read()

f.close()

print "vhdfile:", vhdfile
print "vhdstring:"
print vhdstring
#sys.exit()

entityToken = Keyword("entity", caseless=True).setResultsName("ENT")
endToken = Keyword("end", caseless=True)
portToken = Keyword("port", caseless=True)
ident = Word(alphas, alphanums + "_")
ent_ident = ident.setResultsName("ENT_NAME")
number = Word(nums + ".")
paren = oneOf("( )")
punctuation = oneOf("; :")
direction = oneOf("in out inout")
vecspec = oneOf("downto upto")

portType = oneOf("unsigned signed std_logic_vector std_logic", caseless=True)
portTypeFull = portType + Optional(paren + \
                                   number + \
                                   vecspec + \
                                   Word(nums) + \
                                   paren)
#number = nums
portLine = Group(ident + punctuation + direction + portTypeFull + Optional(punctuation))
portSpec = ZeroOrMore(portLine).setResultsName("PORTLINE")

# top_HDL = Literal("entity") +
# instantiate parser
top_HDL = entityToken + ent_ident + Literal("is") + \
          portToken + paren + portSpec + paren + punctuation + \
          endToken + Optional(entityToken) + ident + punctuation

top_HDL.ignore("--" + restOfLine)
top_HDL.ignore("library" + restOfLine)
top_HDL.ignore("use" + restOfLine)

# parse string
parseres = top_HDL.parseString(vhdstring)

print type(parseres)
print parseres
print parseres.items()
print parseres.keys()
ports = parseres.get("PORTLINE")
print len(ports), ports
#print parseres.asDict()
#print parseres.asXML()
#print type(top_HDL)

############################################################
# start constructing the wrapper output file
vhdfile_wrapper = string.replace(vhdfile, ".vhd", "_wrapper.vhd")
print vhdfile_wrapper

vhdwrap_header = "-- Generated by vhdlparse " + str(VERSION)
vhdwrap_header += "\n-- 20110825 oswald berthold"
vhdwrap_libs = ("library IEEE;", "use IEEE.STD_LOGIC_1164.ALL;")

f = open(vhdfile_wrapper, "w")
f.writelines(vhdwrap_header)
f.write('\n')

for lib in vhdwrap_libs:
    f.write(lib)
    f.write('\n')
f.write('\n')

# gen entity
ent_name = parseres.get("ENT_NAME")
ent_name_wrapper = ent_name + "_wrapper"
ent_name_wrapped = ent_name + "_wrapped"
ent_name_wrapped_inst = ent_name_wrapped + "_inst"
ent_s = [
    "entity " + ent_name_wrapper + " is",
    "\tPort (",
    "\t);",
    "end " + "entity " + ent_name_wrapper + ";"
    ]

i = 0
for port in ports:
    print i, port
    ent_s.insert(2+i, "\t\t" + string.join(port))
    i += 1

for ent_l in ent_s:
    f.write(ent_l)
    f.write("\n")

f.write("\n")

# gen architecture
arch_s = "architecture bhv of " + ent_name_wrapper + " is"
f.write(arch_s)
f.write("\n")

#  components
f.write("-- Components")
f.write("\n")
comp_s = [
    "\tcomponent " + parseres.get("ENT_NAME") + "_wrapped",
    "\t\tPort (",
    "\t\t);",
    "\tend component;"
    ]
i = 0
for port in ports:
    print i, port
    comp_s.insert(2+i, "\t\t\t" + string.join(port))
    i += 1
for comp_l in comp_s:
    f.write(comp_l)
    f.write("\n")
f.write("\n")

#  signals
f.write("-- signals")
f.write("\n")
signals = []
for port in ports:
    print port
    signals.append("\t" + "signal " + port[0] + "_buf " + port[1] + " " + string.join(port[3:len(port)]))
signals[len(signals)-1] += " ;"
for signal in signals:
    f.write(signal)
    f.write("\n")
#  body
f.write("-- body\n")
f.write("begin")
f.write("\n")

#   instantiation
f.write("-- instances")
f.write("\n")
inst_s = [
    "\t" + ent_name_wrapped_inst + " : " + ent_name_wrapped,
    "\t\tport map (",
    "\t\t);"
    ]
i = 0
for port in ports:
    print i, port
    inst_s.insert(2+i, "\t\t\t" + port[0] + " => " + port[0] + "_buf")
    i += 1
i = 0
for inst_l in inst_s:
    f.write(inst_l)
    # check commas in port map
    if (i > 1) and i < (len(inst_s)-2):
        f.write(",")
    f.write("\n")
    i += 1
f.write("\n")

#   def or process
f.write("-- struct/process")
f.write("\n")

# FIXME: clk'ed or nor clk'ed?
# registered

f.write("\t")
f.write("buf_process: process(clk)")
f.write("\n")
f.write("\t")
f.write("begin")
f.write("\n")
f.write("\t\t")
f.write("if rising_edge(clk) then")
f.write("\n")

for port in ports:
    if port[2] == "in":
        print "in"
        f.write("\t\t\t" + port[0] + "_buf" + " <= " + port[0] + " ;")
    elif port[2] == "out":
        print "out"
        f.write("\t\t\t" + port[0] + " <= " + port[0] + "_buf" + " ;")
    else:
        print "neither"
    f.write("\n")

# close register
f.write("\t\t")
f.write("end if;")
f.write("\n")
f.write("\t")
f.write("end process;")
f.write("\n")
    
# clean up
arch_end_s = "end bhv ;"
f.write(arch_end_s)
f.write("\n")


f.flush()
f.close()


sys.exit()

# greet = Word( alphas ) + "," + Word( alphas ) + "!"
# hello = "blub Hello, World!"
# greet.ignore("blub")
# print hello, "->", greet.parseString( hello )
